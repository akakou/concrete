//! The public key for homomorphic computation.
//!
//! This module implements the generation of the server's public key, together with all the
//! available homomorphic Boolean gates ($\mathrm{AND}$, $\mathrm{MUX}$, $\mathrm{NAND}$,
//! $\mathrm{NOR}$,
//! $\mathrm{NOT}$, $\mathrm{OR}$, $\mathrm{XNOR}$, $\mathrm{XOR}$).

#[cfg(test)]
mod tests;

use crate::ciphertext::Ciphertext;
use crate::client_key::ClientKey;
use crate::{PLAINTEXT_FALSE, PLAINTEXT_TRUE};
use concrete_core::prelude::*;
use serde::{Deserialize, Serialize};
use std::fmt::{Debug, Formatter};

/// 'unwrap' the content in an enum variant
///
/// This will panic if the current variant is not the same
/// as the one we want to unwrap
macro_rules! unwrap_variant {
    ($target: expr, $variant: path) => {{
        if let $variant(a) = $target {
            a
        } else {
            panic!("mismatch variant when cast to {}", stringify!($pat));
        }
    }};
}

/// A structure containing the server public key.
///
/// The server key is generated by the client and is meant to be published: the client
/// sends it to the server so it can compute homomorphic Boolean circuits.
///
/// In more details, it contains:
/// * `key_switching_key` - a public key, used to perform the key-switching operation.
/// * `bootstrapping_key` - a public key, used to perform the bootstrapping operation.
#[derive(Serialize, Deserialize)]
pub struct ServerKey {
    pub(crate) key_switching_key: LweKeyswitchKey32,
    pub(crate) bootstrapping_key: FourierLweBootstrapKey32,
    #[serde(skip, default = "crate::default_engine")]
    pub(crate) engine: CoreEngine,
    pub(crate) accumulator: GlweCiphertext32,
    pub(crate) buffer_lwe_before_pbs: LweCiphertext32,
    pub(crate) buffer_lwe_after_pbs: LweCiphertext32,
}

pub trait BinaryBooleanGates<L, R> {
    fn and(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn nand(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn nor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn or(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn xor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
    fn xnor(&mut self, ct_left: L, ct_right: R) -> Ciphertext;
}

pub trait FusingBinaryBooleanGates<L, R> {
    fn fuse_and(&mut self, ct_left: &mut L, ct_right: R);
    fn fuse_nand(&mut self, ct_left: &mut L, ct_right: R);
    fn fuse_nor(&mut self, ct_left: &mut L, ct_right: R);
    fn fuse_or(&mut self, ct_left: &mut L, ct_right: R);
    fn fuse_xor(&mut self, ct_left: &mut L, ct_right: R);
    fn fuse_xnor(&mut self, ct_left: &mut L, ct_right: R);
}

impl PartialEq for ServerKey {
    fn eq(&self, other: &Self) -> bool {
        self.key_switching_key == other.key_switching_key
            && self.bootstrapping_key == other.bootstrapping_key
    }
}

impl Debug for ServerKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServerKey {{ ")?;
        write!(f, "key_switching_key: {:?}, ", self.key_switching_key)?;
        write!(f, "bootstrapping_key: {:?}, ", self.bootstrapping_key)?;
        write!(f, "engine: CoreEngine, ")?;
        write!(f, "accumulator: {:?}, ", self.accumulator)?;
        write!(
            f,
            "buffer_lwe_before_pbs: {:?}, ",
            self.buffer_lwe_before_pbs
        )?;
        write!(f, "buffer_lwe_after_pbs: {:?}, ", self.buffer_lwe_after_pbs)?;
        write!(f, "}}")?;
        Ok(())
    }
}

impl Clone for ServerKey {
    fn clone(&self) -> ServerKey {
        let sks_clone: ServerKey = ServerKey {
            key_switching_key: self.key_switching_key.clone(),
            bootstrapping_key: self.bootstrapping_key.clone(),
            accumulator: self.accumulator.clone(),
            buffer_lwe_before_pbs: self.buffer_lwe_before_pbs.clone(),
            buffer_lwe_after_pbs: self.buffer_lwe_after_pbs.clone(),
            engine: crate::default_engine(),
        };
        sks_clone
    }
}

impl ServerKey {
    /// Allocates and generates a server key.
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::client_key::ClientKey;
    /// use concrete_boolean::parameters::DEFAULT_PARAMETERS;
    /// use concrete_boolean::server_key::ServerKey;
    ///
    /// // Generate the client key:
    /// let cks = ClientKey::new(DEFAULT_PARAMETERS);
    ///
    /// // Generate the server key:
    /// let sks = ServerKey::new(&cks);
    /// ```
    pub fn new(cks: &ClientKey) -> ServerKey {
        // creation of a core-engine
        let mut engine = super::default_engine();

        // convert into a variance for rlwe context
        let var_rlwe = Variance(cks.parameters.glwe_modular_std_dev.get_variance());

        // creation of the bootstrapping key in the Fourier domain
        let fourier_bsk: FourierLweBootstrapKey32 = engine
            .create_lwe_bootstrap_key(
                &cks.lwe_secret_key,
                &cks.glwe_secret_key,
                cks.parameters.pbs_base_log,
                cks.parameters.pbs_level,
                var_rlwe,
            )
            .unwrap();

        // Convert the GLWE secret key into an LWE secret key:
        let big_lwe_secret_key = engine
            .transmute_glwe_secret_key_to_lwe_secret_key(cks.glwe_secret_key.clone())
            .unwrap();

        // convert into a variance for lwe context
        let var_lwe = Variance(cks.parameters.lwe_modular_std_dev.get_variance());

        // creation of the key switching key
        let ksk = engine
            .create_lwe_keyswitch_key(
                &big_lwe_secret_key,
                &cks.lwe_secret_key,
                cks.parameters.ks_level,
                cks.parameters.ks_base_log,
                var_lwe,
            )
            .unwrap();

        // create the accumulator
        let accumulator_u32 = vec![PLAINTEXT_TRUE; fourier_bsk.polynomial_size().0]; // 1/8
                                                                                     // everywhere
        let accumulator_plaintext = engine.create_plaintext_vector(&accumulator_u32).unwrap();
        let accumulator = engine
            .trivially_encrypt_glwe_ciphertext(
                GlweSize(fourier_bsk.glwe_dimension().0 + 1),
                &accumulator_plaintext,
            )
            .unwrap();

        // Allocate the buffer for the input of the PBS
        let zero_plaintext = engine.create_plaintext(&0_u32).unwrap();
        let buffer_lwe_before_pbs = engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(ksk.output_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Allocate the buffer for the output of the PBS
        let zero_plaintext = engine.create_plaintext(&0_u32).unwrap();
        let buffer_lwe_after_pbs = engine
            .trivially_encrypt_lwe_ciphertext(
                LweSize(ksk.input_lwe_dimension().0 + 1),
                &zero_plaintext,
            )
            .unwrap();

        // Pack the keys in the server key set:
        let sks: ServerKey = ServerKey {
            key_switching_key: ksk,
            bootstrapping_key: fourier_bsk,
            engine,
            accumulator,
            buffer_lwe_before_pbs,
            buffer_lwe_after_pbs,
        };
        sks
    }

    /// Trivially encrypts a Boolean message, i.e. does not encrypt at all!
    /// The output is a Ciphertext and can be provided as a input to any gate as if it was truly
    /// encrypted.
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Trivial encryption of one message:
    /// let ct = sks.trivial_encrypt(true);
    ///
    /// // Decryption:
    /// let dec = cks.decrypt(&ct);
    /// assert_eq!(true, dec);
    /// ```
    pub fn trivial_encrypt(&mut self, message: bool) -> Ciphertext {
        Ciphertext::Trivial(message)
    }

    /// convert into an actual LWE ciphertext even when trivial
    fn convert_into_lwe_ciphertext_32(&mut self, ct: &Ciphertext) -> LweCiphertext32 {
        match ct {
            Ciphertext::Encrypted(ct_ct) => ct_ct.clone(),
            Ciphertext::Trivial(message) => {
                // encode the boolean message
                let plain: Plaintext32 = if *message {
                    self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap()
                } else {
                    self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap()
                };
                self.engine
                    .trivially_encrypt_lwe_ciphertext(
                        LweSize(self.key_switching_key.output_lwe_dimension().0 + 1),
                        &plain,
                    )
                    .unwrap()
            }
        }
    }

    /// function that computes a bootstrap and a keys witch
    fn bootstrap_keyswitch(&mut self, ciphertext: &mut LweCiphertext32) {
        // Compute the programmable bootstrapping with fixed test polynomial
        self.engine
            .discard_bootstrap_lwe_ciphertext(
                &mut self.buffer_lwe_after_pbs,
                ciphertext,
                &self.accumulator,
                &self.bootstrapping_key,
            )
            .unwrap();

        // Compute a key switch to get back to input key
        self.engine
            .discard_keyswitch_lwe_ciphertext(
                ciphertext,
                &self.buffer_lwe_after_pbs,
                &self.key_switching_key,
            )
            .unwrap();
    }

    /// Computes an homomorphic MUX gate between three ciphertexts encrypting Boolean values:
    /// $$ct_{out} = (ct_{condition}?~ct_{then}:~ct_{else}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt three messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    /// let ct3 = cks.encrypt(true);
    ///
    /// // Compute homomorphically a MUX gate:
    /// let ct_res = sks.mux(&ct1, &ct2, &ct3);
    ///
    /// // Decrypt:
    /// let dec_mux = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_mux);
    /// ```
    pub fn mux(
        &mut self,
        ct_condition: &Ciphertext,
        ct_then: &Ciphertext,
        ct_else: &Ciphertext,
    ) -> Ciphertext {
        // In theory MUX gate = (ct_condition AND ct_then) + (!ct_condition AND ct_else)

        match ct_condition {
            // in the case of the condition is trivially encrypted
            Ciphertext::Trivial(message_condition) => {
                if *message_condition {
                    ct_then.clone()
                } else {
                    ct_else.clone()
                }
            }
            Ciphertext::Encrypted(ct_condition_ct) => {
                // condition is actually encrypted

                // take a shortcut if ct_then is trivially encrypted
                if let Ciphertext::Trivial(message_then) = ct_then {
                    return if *message_then {
                        self.or(ct_condition, ct_else)
                    } else {
                        let ct_not_condition = self.not(ct_condition);
                        self.and(&ct_not_condition, ct_else)
                    };
                }

                // take a shortcut if ct_else is trivially encrypted
                if let Ciphertext::Trivial(message_else) = ct_else {
                    return if *message_else {
                        let ct_not_condition = self.not(ct_condition);
                        self.or(ct_then, &ct_not_condition)
                    } else {
                        self.and(ct_condition, ct_then)
                    };
                }

                // convert inputs into LweCiphertext32
                let ct_then_ct = self.convert_into_lwe_ciphertext_32(ct_then);
                let ct_else_ct = self.convert_into_lwe_ciphertext_32(ct_else);

                // Compute the linear combination for first AND: ct_condition + ct_then +
                // (0,...,0,-1/8)
                self.engine
                    .discard_add_lwe_ciphertext(
                        &mut self.buffer_lwe_before_pbs,
                        ct_condition_ct,
                        &ct_then_ct,
                    )
                    .unwrap(); // ct_condition + ct_then
                let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_before_pbs, &cst)
                    .unwrap(); //
                               // - 1/8

                // Compute the linear combination for second AND: - ct_condition + ct_else +
                // (0,...,0,-1/8)
                let mut ct_temp_2 = ct_condition_ct.clone(); // ct_condition
                self.engine.fuse_neg_lwe_ciphertext(&mut ct_temp_2).unwrap(); // compute the negation
                self.engine
                    .fuse_add_lwe_ciphertext(&mut ct_temp_2, &ct_else_ct)
                    .unwrap(); // + ct_else
                let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(&mut ct_temp_2, &cst)
                    .unwrap(); //
                               // - 1/8

                // Compute the first programmable bootstrapping with fixed test polynomial:
                self.engine
                    .discard_bootstrap_lwe_ciphertext(
                        &mut self.buffer_lwe_after_pbs,
                        &self.buffer_lwe_before_pbs,
                        &self.accumulator,
                        &self.bootstrapping_key,
                    )
                    .unwrap();

                // Allocate the output of the second PBS:
                let mut ct_pbs_2 = self.buffer_lwe_after_pbs.clone();

                // Compute the second programmable bootstrapping with fixed test polynomial:
                self.engine
                    .discard_bootstrap_lwe_ciphertext(
                        &mut ct_pbs_2,
                        &ct_temp_2,
                        &self.accumulator,
                        &self.bootstrapping_key,
                    )
                    .unwrap();

                // Compute the linear combination to add the two results : buffer_lwe_pbs + ct_pbs_2
                // + (0,...,0,
                // +1/8)
                self.engine
                    .fuse_add_lwe_ciphertext(&mut self.buffer_lwe_after_pbs, &ct_pbs_2)
                    .unwrap(); // + buffer_lwe_pbs
                let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(&mut self.buffer_lwe_after_pbs, &cst)
                    .unwrap(); // + 1/8

                // Allocate the output of the KS
                let zero_plaintext = self.engine.create_plaintext(&0_u32).unwrap();
                let mut ct_ks = self
                    .engine
                    .trivially_encrypt_lwe_ciphertext(
                        LweSize(self.key_switching_key.output_lwe_dimension().0 + 1),
                        &zero_plaintext,
                    )
                    .unwrap();

                // Compute the key switch to get back to input key
                self.engine
                    .discard_keyswitch_lwe_ciphertext(
                        &mut ct_ks,
                        &self.buffer_lwe_after_pbs,
                        &self.key_switching_key,
                    )
                    .unwrap();

                // Output the result:
                Ciphertext::Encrypted(ct_ks)
            }
        }
    }

    /// Computes homomorphically a NOT gate of a ciphertexts encrypting a Boolean value:
    /// $$ct_{out} = \mathrm{NOT}(ct_{in})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::gen_keys;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt a message:
    /// let ct = cks.encrypt(true);
    ///
    /// // Compute homomorphically a NOT gate:
    /// let ct_res = sks.not(&ct);
    ///
    /// // Decrypt:
    /// let dec_not = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_not);
    /// ```
    pub fn not(&mut self, ct: &Ciphertext) -> Ciphertext {
        let mut result = ct.clone();
        self.inplace_not(&mut result);
        result
    }

    pub fn inplace_not(&mut self, mut ct: &mut Ciphertext) {
        match &mut ct {
            Ciphertext::Trivial(message) => {
                *ct = Ciphertext::Trivial(!*message);
            }
            Ciphertext::Encrypted(ct_ct) => {
                // Compute the linear combination for NOT: -ct
                self.engine.fuse_neg_lwe_ciphertext(ct_ct).unwrap();
            }
        }
    }
}

impl FusingBinaryBooleanGates<Ciphertext, &Ciphertext> for ServerKey {
    fn fuse_and(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(*message_left && *message_right);
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_and(ct_left, *message_right);
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_and(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // compute the linear combination for AND: ct_left + ct_right + (0,...,0,-1/8)
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst)
                    .unwrap(); //
                               // - 1/8

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct);
            }
        }
    }

    fn fuse_nand(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(!(*message_left && *message_right));
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_nand(ct_left, *message_right)
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_nand(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // Compute the linear combination for NAND: - ct_left - ct_right + (0,...,0,1/8)
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                self.engine.fuse_neg_lwe_ciphertext(ct_left_ct).unwrap(); // compute the negation
                let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst)
                    .unwrap(); // + 1/8

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct)
            }
        }
    }

    fn fuse_nor(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(!(*message_left || *message_right));
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_nor(ct_left, *message_right);
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_nor(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // Compute the linear combination for NOR: - ct_left - ct_right + (0,...,0,-1/8)
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                self.engine.fuse_neg_lwe_ciphertext(ct_left_ct).unwrap(); // compute the negation
                let cst = self.engine.create_plaintext(&PLAINTEXT_FALSE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst)
                    .unwrap(); //
                               // - 1/8

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct);
            }
        }
    }

    fn fuse_or(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(*message_left || *message_right);
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_or(ct_left, *message_right)
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_or(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // Compute the linear combination for OR: ct_left + ct_right + (0,...,0,+1/8)
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                let cst = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst)
                    .unwrap(); // + 1/8

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct);
            }
        }
    }

    fn fuse_xor(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(*message_left ^ *message_right);
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_xor(ct_left, *message_right)
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_xor(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // Compute the linear combination for XOR: 2*(ct_left + ct_right) + (0,...,0,1/4)
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                let cst_add = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst_add)
                    .unwrap(); // + 1/8
                let cst_mul = self.engine.create_cleartext(&2u32).unwrap();
                self.engine
                    .fuse_mul_lwe_ciphertext_cleartext(ct_left_ct, &cst_mul)
                    .unwrap(); //* 2

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct);
            }
        }
    }

    fn fuse_xnor(&mut self, mut ct_left: &mut Ciphertext, ct_right: &Ciphertext) {
        match (&mut ct_left, ct_right) {
            (Ciphertext::Trivial(message_left), Ciphertext::Trivial(message_right)) => {
                *ct_left = Ciphertext::Trivial(!(*message_left ^ *message_right));
            }
            (Ciphertext::Encrypted(_), Ciphertext::Trivial(message_right)) => {
                self.fuse_xnor(ct_left, *message_right)
            }
            (Ciphertext::Trivial(_), Ciphertext::Encrypted(_)) => {
                let message = *unwrap_variant!(ct_left, Ciphertext::Trivial);
                ct_left.clone_from(ct_right);
                self.fuse_xnor(ct_left, message);
            }
            (Ciphertext::Encrypted(ct_left_ct), Ciphertext::Encrypted(ct_right_ct)) => {
                // Compute the linear combination for XNOR: 2*(-ct_left - ct_right + (0,...,0,-1/8))
                self.engine
                    .fuse_add_lwe_ciphertext(ct_left_ct, ct_right_ct)
                    .unwrap(); // ct_left + ct_right
                let cst_add = self.engine.create_plaintext(&PLAINTEXT_TRUE).unwrap();
                self.engine
                    .fuse_add_lwe_ciphertext_plaintext(ct_left_ct, &cst_add)
                    .unwrap(); // + 1/8
                self.engine.fuse_neg_lwe_ciphertext(ct_left_ct).unwrap(); // compute the negation
                let cst_mul = self.engine.create_cleartext(&2u32).unwrap();
                self.engine
                    .fuse_mul_lwe_ciphertext_cleartext(ct_left_ct, &cst_mul)
                    .unwrap(); //* 2

                // compute the bootstrap and the key switch
                self.bootstrap_keyswitch(ct_left_ct);
            }
        }
    }
}

impl FusingBinaryBooleanGates<Ciphertext, bool> for ServerKey {
    /// Computes homomorphically an AND gate between one ciphertext encrypting Boolean value and
    /// a clear boolean
    /// $$ ct_{left} = ct_{left} ~\mathrm{AND}~ct_{right} $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute homomorphically an AND gate:
    /// sks.fuse_and(&mut ct1, false);
    ///
    /// // Decrypt:
    /// let dec_and = cks.decrypt(&ct1);
    /// assert_eq!(false, dec_and);
    /// ```
    fn fuse_and(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        // if ct_right is true we have:
        // ct AND true = ct
        // so we don't touch ct_left
        if !ct_right {
            // ct AND false = false
            *ct_left = self.trivial_encrypt(false)
        }
    }

    /// Computes homomorphically a NAND gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{left} = \mathrm{NOT} (ct_{left}~\mathrm{AND}~ct_{right})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute homomorphically a NAND gate:
    /// sks.fuse_nand(&mut ct1, false);
    ///
    /// // Decrypt:
    /// let dec_nand = cks.decrypt(&ct1);
    /// assert_eq!(true, dec_nand);
    /// ```
    fn fuse_nand(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        if ct_right {
            // NOT (ct AND true) = NOT(ct)
            self.inplace_not(ct_left);
        } else {
            // NOT (ct AND false) = NOT(false) = true
            *ct_left = self.trivial_encrypt(true);
        }
    }
    /// Computes homomorphically a NOR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ ct_{left} = \mathrm{NOT}(ct_{left}~\mathrm{OR}~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute homomorphically the NOR gate:
    /// sks.fuse_nor(&mut ct1, false);
    ///
    /// // Decrypt:
    /// let dec_nor = cks.decrypt(&ct1);
    /// assert_eq!(false, dec_nor);
    /// ```
    fn fuse_nor(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        if ct_right {
            // NOT (ct OR true) = NOT(true) = false
            *ct_left = self.trivial_encrypt(false)
        } else {
            // NOT (ct OR false) = NOT(ct)
            self.inplace_not(ct_left)
        }
    }

    /// Computes homomorphically an OR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{left} = ct_{left}~\mathrm{OR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute homomorphically the OR gate:
    /// sks.fuse_or(&mut ct1, false);
    ///
    /// // Decrypt:
    /// let dec_or = cks.decrypt(&ct1);
    /// assert_eq!(true, dec_or);
    /// ```
    fn fuse_or(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        // if ct_right is false, we have
        // ct OR false = ct

        if ct_right {
            // ct OR true = true
            *ct_left = self.trivial_encrypt(true)
        }
    }
    /// Computes homomorphically an XOR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{left}= ct_{left}~\mathrm{XOR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute the XOR gate:
    /// sks.fuse_xor(&mut ct1, false);
    ///
    /// // Decryption:
    /// let dec_xor = cks.decrypt(&ct1);
    /// assert_eq!(true, dec_xor);
    /// ```
    fn fuse_xor(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        // if ct_right is false, we have
        // ct XOR false = ct

        if ct_right {
            // ct XOR true = NOT(ct)
            self.inplace_not(ct_left)
        }
    }
    /// Computes homomorphically an XNOR gate (or equality test) between one ciphertext encrypting
    /// Boolean value and a clear boolean:
    /// $$ct_{left} = (ct_{left}~==~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// let mut ct1 = cks.encrypt(true);
    ///
    /// // Compute the XNOR gate:
    /// sks.fuse_xnor(&mut ct1, false);
    ///
    /// // Decrypt:
    /// let dec_xnor = cks.decrypt(&ct1);
    /// assert_eq!(false, dec_xnor);
    /// ```
    fn fuse_xnor(&mut self, ct_left: &mut Ciphertext, ct_right: bool) {
        // if ct_right is true, we have
        // NOT(ct XOR true) = NOT(NOT(ct)) = ct

        if !ct_right {
            // NOT(ct XOR false) = NOT(ct)
            self.inplace_not(ct_left);
        }
    }
}

impl BinaryBooleanGates<&Ciphertext, &Ciphertext> for ServerKey {
    /// Computes homomorphically an AND gate between two ciphertexts encrypting Boolean values:
    /// $$ ct_{out} = ct_{left}~\mathrm{AND}~ct_{right} $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically an AND gate:
    /// let ct_res = sks.and(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_and = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_and);
    /// ```
    fn and(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_and(&mut result, ct_right);
        result
    }

    /// Computes homomorphically a NAND gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out} = \mathrm{NOT} (ct_{left}~\mathrm{AND}~ct_{right})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically a NAND gate:
    /// let ct_res = sks.nand(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nand = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_nand);
    /// ```
    fn nand(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_nand(&mut result, ct_right);
        result
    }

    /// Computes homomorphically a NOR gate between two ciphertexts encrypting Boolean values:
    /// $$ ct_{out} = \mathrm{NOT}(ct_{left}~\mathrm{OR}~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the NOR gate:
    /// let ct_res = sks.nor(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_nor);
    /// ```
    fn nor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_nor(&mut result, ct_right);
        result
    }

    /// Computes homomorphically an OR gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out} = ct_{left}~\mathrm{OR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the OR gate:
    /// let ct_res = sks.or(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_or = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_or);
    /// ```
    fn or(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_or(&mut result, ct_right);
        result
    }

    /// Computes homomorphically an XOR gate between two ciphertexts encrypting Boolean values:
    /// $$ct_{out}= ct_{left}~\mathrm{XOR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encryption of two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XOR gate:
    /// let ct_res = sks.xor(&ct1, &ct2);
    ///
    /// // Decryption:
    /// let dec_xor = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_xor);
    /// ```
    fn xor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_xor(&mut result, ct_right);
        result
    }

    /// Computes homomorphically an XNOR gate (or equality test) between two ciphertexts encrypting
    /// Boolean values:
    /// $$ct_{out} = (ct_{left}~==~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XNOR gate:
    /// let ct_res = sks.xnor(&ct1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_xnor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_xnor);
    /// ```
    fn xnor(&mut self, ct_left: &Ciphertext, ct_right: &Ciphertext) -> Ciphertext {
        let mut result = ct_left.clone();
        self.fuse_xnor(&mut result, ct_right);
        result
    }
}

impl BinaryBooleanGates<&Ciphertext, bool> for ServerKey {
    /// Computes homomorphically an AND gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ ct_{out} = ct_{left}~\mathrm{AND}~ct_{right} $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute homomorphically an AND gate:
    /// let ct_res = sks.and(&ct1, bool2);
    ///
    /// // Decrypt:
    /// let dec_and = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_and);
    /// ```
    fn and(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // ct AND true = ct
            ct_left.clone()
        } else {
            // ct AND false = false
            self.trivial_encrypt(false)
        }
    }

    /// Computes homomorphically a NAND gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{out} = \mathrm{NOT} (ct_{left}~\mathrm{AND}~ct_{right})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute homomorphically a NAND gate:
    /// let ct_res = sks.nand(&ct1, bool2);
    ///
    /// // Decrypt:
    /// let dec_nand = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_nand);
    /// ```
    fn nand(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // NOT (ct AND true) = NOT(ct)
            self.not(ct_left)
        } else {
            // NOT (ct AND false) = NOT(false) = true
            self.trivial_encrypt(true)
        }
    }

    /// Computes homomorphically a NOR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ ct_{out} = \mathrm{NOT}(ct_{left}~\mathrm{OR}~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute homomorphically the NOR gate:
    /// let ct_res = sks.nor(&ct1, bool2);
    ///
    /// // Decrypt:
    /// let dec_nor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_nor);
    /// ```
    fn nor(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // NOT (ct OR true) = NOT(true) = false
            self.trivial_encrypt(false)
        } else {
            // NOT (ct OR false) = NOT(ct)
            self.not(ct_left)
        }
    }

    /// Computes homomorphically an OR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{out} = ct_{left}~\mathrm{OR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute homomorphically the OR gate:
    /// let ct_res = sks.or(&ct1, bool2);
    ///
    /// // Decrypt:
    /// let dec_or = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_or);
    /// ```
    fn or(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // ct OR true = true
            self.trivial_encrypt(true)
        } else {
            // ct OR false = ct
            ct_left.clone()
        }
    }

    /// Computes homomorphically an XOR gate between one ciphertext encrypting Boolean value and
    /// a clear boolean:
    /// $$ct_{out}= ct_{left}~\mathrm{XOR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encryption of two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute the XOR gate:
    /// let ct_res = sks.xor(&ct1, bool2);
    ///
    /// // Decryption:
    /// let dec_xor = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_xor);
    /// ```
    fn xor(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // ct XOR true = NOT(ct)
            self.not(ct_left)
        } else {
            // ct XOR false = ct
            ct_left.clone()
        }
    }

    /// Computes homomorphically an XNOR gate (or equality test) between one ciphertext encrypting
    /// Boolean value and a clear boolean:
    /// $$ct_{out} = (ct_{left}~==~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let ct1 = cks.encrypt(true);
    /// let bool2 = false;
    ///
    /// // Compute the XNOR gate:
    /// let ct_res = sks.xnor(&ct1, bool2);
    ///
    /// // Decrypt:
    /// let dec_xnor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_xnor);
    /// ```
    fn xnor(&mut self, ct_left: &Ciphertext, ct_right: bool) -> Ciphertext {
        if ct_right {
            // NOT(ct XOR true) = NOT(NOT(ct)) = ct
            ct_left.clone()
        } else {
            // NOT(ct XOR false) = NOT(ct)
            self.not(ct_left)
        }
    }
}

impl BinaryBooleanGates<bool, &Ciphertext> for ServerKey {
    /// Computes homomorphically an AND gate between a clear boolean and one ciphertext encrypting
    /// a Boolean value:
    /// $$ ct_{out} = ct_{left}~\mathrm{AND}~ct_{right} $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically an AND gate:
    /// let ct_res = sks.and(bool1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_and = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_and);
    /// ```
    fn and(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.and(ct_right, ct_left)
    }

    /// Computes homomorphically a NAND gate between a clear boolean and one ciphertext encrypting
    /// a Boolean value:
    /// $$ct_{out} = \mathrm{NOT} (ct_{left}~\mathrm{AND}~ct_{right})$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically a NAND gate:
    /// let ct_res = sks.nand(bool1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nand = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_nand);
    /// ```
    fn nand(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.nand(ct_right, ct_left)
    }

    /// Computes homomorphically a NOR gate between a clear boolean and one ciphertext encrypting
    /// a Boolean value:
    /// $$ ct_{out} = \mathrm{NOT}(ct_{left}~\mathrm{OR}~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the NOR gate:
    /// let ct_res = sks.nor(bool1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_nor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_nor);
    /// ```
    fn nor(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.nor(ct_right, ct_left)
    }

    /// Computes homomorphically an OR gate between a clear boolean and one ciphertext encrypting
    /// a Boolean value:
    /// $$ct_{out} = ct_{left}~\mathrm{OR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute homomorphically the OR gate:
    /// let ct_res = sks.or(bool1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_or = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_or);
    /// ```
    fn or(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.or(ct_right, ct_left)
    }

    /// Computes homomorphically an XOR gate between a clear boolean and one ciphertext encrypting
    /// a Boolean value:
    /// $$ct_{out}= ct_{left}~\mathrm{XOR}~ct_{right}$$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encryption of two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XOR gate:
    /// let ct_res = sks.xor(bool1, &ct2);
    ///
    /// // Decryption:
    /// let dec_xor = cks.decrypt(&ct_res);
    /// assert_eq!(true, dec_xor);
    /// ```
    fn xor(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.xor(ct_right, ct_left)
    }

    /// Computes homomorphically an XNOR gate (or equality test) between a clear boolean and one
    /// ciphertext encrypting a Boolean value:
    /// $$ct_{out} = (ct_{left}~==~ct_{right}) $$
    ///
    /// # Example
    ///
    /// ```rust
    /// use concrete_boolean::prelude::*;
    ///
    /// // Generate the client key and the server key:
    /// let (mut cks, mut sks) = gen_keys();
    ///
    /// // Encrypt two messages:
    /// let bool1 = true;
    /// let ct2 = cks.encrypt(false);
    ///
    /// // Compute the XNOR gate:
    /// let ct_res = sks.xnor(bool1, &ct2);
    ///
    /// // Decrypt:
    /// let dec_xnor = cks.decrypt(&ct_res);
    /// assert_eq!(false, dec_xnor);
    /// ```
    fn xnor(&mut self, ct_left: bool, ct_right: &Ciphertext) -> Ciphertext {
        self.xnor(ct_right, ct_left)
    }
}
